#!r6rs
(library (rhs) (export negate enum-from-difference-to enum-from-then-to enum-from-to pred signum succ replicate-m* replicate-m otherwise and2 and3 or2 or3 compose const flip id on all all-true any break concat concat-map delete-by delete drop drop-while elem elem-index elem-indices find-index* find-index find-indices* find-indices foldl foldl1 foldr foldr1 group-by head init insert insert-by intercalate intersperse is-infix-of is-prefix-of is-suffix-of iterate last list1 list2 list3 list4 list5 !! lookup map-accum-l map-accum-r maximum minimum nub nub-by nil not-elem any-true partition* product replicate scanl scanl1 scanr scanr1 sort sort-by span split-at sum tail take take-while transpose unfoldr union union-by zip zip-with zip-with3 compare flatten* flatten levels curry uncurry) (import (only (rnrs) quote define define-record-type fields define-syntax syntax-rules lambda let let* letrec if cond else cons car cdr pair? list equal? = + - * / and or even? odd? > < >= <= error) (prefix (srfi s9 records) srfi:)) (define negate (lambda (n) (- n))) (define enum-from-difference-to (lambda (f i x k) (cond ((= i k) (list1 k)) ((f i k) nil) (else (cons i (enum-from-difference-to f (+ i x) x k)))))) (define enum-from-then-to (lambda (i j k) (let ((x (- j i))) (enum-from-difference-to (if (> x 0) > <) i x k)))) (define enum-from-to (lambda (i j) (enum-from-then-to i (succ i) j))) (define pred (lambda (x) (- x 1))) (define signum (lambda (x) (cond ((> x 0) 1) ((< x 0) -1) (else 0)))) (define succ (lambda (x) (+ x 1))) (define replicate-m* (lambda (i x) (if (<= i 0) nil (cons (x) (replicate-m* (- i 1) x))))) (define-syntax replicate-m (syntax-rules () ((_ i x) (replicate-m* i (lambda () x))))) (define otherwise #t) (define not (lambda (x) (if (equal? x #f) #t #f))) (define-syntax and2 (syntax-rules () ((_ p q) (if p q #f)))) (define-syntax and3 (syntax-rules () ((_ p q r) (and2 p (and2 q r))))) (define-syntax or2 (syntax-rules () ((_ p q) (if p p q)))) (define-syntax or3 (syntax-rules () ((_ p q r) (or2 p (or2 q r))))) (define compose (lambda (f g) (lambda (x) (f (g x))))) (define const (lambda (x) (lambda (_) x))) (define flip (lambda (f) (lambda (x y) (f y x)))) (define id (lambda (x) x)) (define on (lambda (j f) (lambda (x y) (j (f x) (f y))))) (define all (lambda (f l) (if (null? l) #t (and (f (car l)) (all f (cdr l)))))) (define all-true (lambda (l) (if (null? l) #t (and (car l) (all-true (cdr l)))))) (define any (lambda (f l) (if (null? l) #f (or (f (car l)) (any f (cdr l)))))) (define append (lambda (a b) (if (null? a) b (cons (car a) (append (cdr a) b))))) (define break (lambda (p l) (span (compose not p) l))) (define concat (lambda (l) (foldr append nil l))) (define concat-map (lambda (f l) (concat (map f l)))) (define delete-by (lambda (f x l) (if (null? l) nil (if (f x (car l)) (cdr l) (cons (car l) (delete-by f x (cdr l))))))) (define delete (lambda (x l) (delete-by equal? x l))) (define drop (lambda (n l) (cond ((<= n 0) l) ((null? l) nil) (else (drop (- n 1) (cdr l)))))) (define drop-while (lambda (p l) (if (null? l) nil (if (p (car l)) (drop-while p (cdr l)) l)))) (define elem (lambda (x l) (any (lambda (y) (equal? x y)) l))) (define elem-index (lambda (x l) (find-index (lambda (y) (equal? x y)) l))) (define elem-indices (lambda (x l) (find-indices (lambda (y) (equal? x y)) l))) (define find (lambda (f l) (if (null? l) #f (if (f (car l)) (car l) (find f (cdr l)))))) (define find-index* (lambda (f l n) (if (null? l) #f (if (f (car l)) n (find-index* f (cdr l) (+ n 1)))))) (define find-index (lambda (f l) (find-index* f l 0))) (define find-indices* (lambda (f l n) (if (null? l) nil (if (f (car l)) (cons n (find-indices* f (cdr l) (+ n 1))) (find-indices* f (cdr l) (+ n 1)))))) (define find-indices (lambda (f l) (find-indices* f l 0))) (define filter (lambda (f l) (if (null? l) nil (let ((x (car l)) (xs (cdr l))) (if (f x) (cons x (filter f xs)) (filter f xs)))))) (define foldl (lambda (f z l) (if (null? l) z (foldl f (f z (car l)) (cdr l))))) (define foldl1 (lambda (f l) (foldl f (car l) (cdr l)))) (define foldr (lambda (f z l) (if (null? l) z (f (car l) (foldr f z (cdr l)))))) (define foldr1 (lambda (f l) (if (null? (cdr l)) (car l) (f (car l) (foldr1 f (cdr l)))))) (define group-by (lambda (f l) (if (null? l) (quote ()) (let* ((x (car l)) (yz (span (lambda (e) (f e x)) (cdr l)))) (cons (cons x (car yz)) (group-by f (cdr yz))))))) (define head car) (define init (lambda (l) (let ((x (car l)) (xs (cdr l))) (if (null? xs) nil (cons x (init xs)))))) (define insert (lambda (e l) (insert-by compare e l))) (define insert-by (lambda (f x l) (if (null? l) (list1 x) (if (equal? (f x (car l)) (quote gt)) (cons (car l) (insert-by f x (cdr l))) (cons x l))))) (define intercalate (lambda (e l) (concat (intersperse e l)))) (define intersperse (lambda (x l) (cond ((null? l) nil) ((null? (cdr l)) l) (else (cons (car l) (cons x (intersperse x (cdr l)))))))) (define is-infix-of (lambda (p q) (cond ((null? p) #t) ((null? q) #f) (else (or (is-prefix-of p q) (is-infix-of p (cdr q))))))) (define is-prefix-of (lambda (p q) (cond ((null? p) #t) ((null? q) #f) (else (and (equal? (car p) (car q)) (is-prefix-of (cdr p) (cdr q))))))) (define is-suffix-of (lambda (p q) (is-prefix-of (reverse p) (reverse q)))) (define iterate (lambda (n f z) (if (equal? n 0) z (iterate (- n 1) f (f z))))) (define last (lambda (l) (let ((xs (cdr l))) (if (null? xs) (car l) (last xs))))) (define length (lambda (l) (if (null? l) 0 (+ 1 (length (cdr l)))))) (define list1 (lambda (x) (cons x nil))) (define list2 (lambda (x y) (cons x (cons y nil)))) (define list3 (lambda (x y z) (cons x (cons y (cons z nil))))) (define list4 (lambda (x y z a) (cons x (cons y (cons z (cons a nil)))))) (define list5 (lambda (x y z a b) (cons x (cons y (cons z (cons a (cons b nil))))))) (define list-ref (lambda (l n) (if (= n 0) (car l) (list-ref (cdr l) (- n 1))))) (define !! list-ref) (define lookup (lambda (x l) (if (null? l) #f (if (equal? (car (car l)) x) (cdr (car l)) (lookup x (cdr l)))))) (define map (lambda (f l) (if (null? l) nil (cons (f (car l)) (map f (cdr l)))))) (define map-accum-l (lambda (f s l) (if (null? l) (cons s nil) (let* ((a (f s (car l))) (b (map-accum-l f (car a) (cdr l)))) (cons (car a) (cons (cdr a) (cdr b))))))) (define map-accum-r (lambda (f s l) (if (null? l) (cons s nil) (let* ((a (map-accum-r f s (cdr l))) (b (f (car a) (car l)))) (cons (car b) (cons (cdr b) (cdr a))))))) (define maximum (lambda (l) (foldl1 max l))) (define minimum (lambda (l) (foldl1 min l))) (define nub (lambda (l) (nub-by equal? l))) (define nub-by (lambda (f l) (if (null? l) nil (let ((x (car l)) (xs (cdr l))) (cons x (nub-by f (filter (lambda (y) (not (f x y))) xs))))))) (define nil (quote ())) (define not-elem (lambda (x l) (all (lambda (y) (not (equal? x y))) l))) (define null? (lambda (x) (equal? x nil))) (define any-true (lambda (l) (if (null? l) #f (or (car l) (any-true (cdr l)))))) (define partition* (let ((select (lambda (p) (lambda (x tf) (let ((t (car tf)) (f (cdr tf))) (if (p x) (cons (cons x t) f) (cons t (cons x f)))))))) (lambda (p xs) (foldr (select p) (cons nil nil) xs)))) (define product (lambda (l) (foldl * 1 l))) (define replicate (lambda (n x) (if (= n 0) nil (cons x (replicate (- n 1) x))))) (define reverse (lambda (l) (foldl (flip cons) nil l))) (define scanl (lambda (f q l) (cons q (if (null? l) nil (scanl f (f q (car l)) (cdr l)))))) (define scanl1 (lambda (f l) (if (null? l) nil (scanl f (car l) (cdr l))))) (define scanr (lambda (f q0 l) (if (null? l) (list1 q0) (let ((qs (scanr f q0 (cdr l)))) (cons (f (car l) (car qs)) qs))))) (define scanr1 (lambda (f l) (if (null? l) nil (if (null? (cdr l)) l (let ((qs (scanr1 f (cdr l)))) (cons (f (car l) (car qs)) qs)))))) (define sort (lambda (l) (sort-by compare l))) (define sort-by (lambda (f l) (mergesort f l))) (define mergesort (lambda (f l) (mergesort* f (map list1 l)))) (define mergesort* (lambda (f l) (cond ((null? l) nil) ((null? (cdr l)) (car l)) (else (mergesort* f (merge-pairs f l)))))) (define merge-pairs (lambda (f l) (cond ((null? l) nil) ((null? (cdr l)) l) (else (cons (merge f (car l) (car (cdr l))) (merge-pairs f (cdr (cdr l)))))))) (define merge (lambda (f l r) (cond ((null? l) r) ((null? r) l) (else (if (equal? (f (car l) (car r)) (quote gt)) (cons (car r) (merge f l (cdr r))) (cons (car l) (merge f (cdr l) r))))))) (define span (lambda (p l) (if (null? l) (cons nil nil) (if (p (car l)) (let ((r (span p (cdr l)))) (cons (cons (car l) (car r)) (cdr r))) (cons nil l))))) (define split-at (lambda (n l) (cons (take n l) (drop n l)))) (define sum (lambda (l) (foldl + 0 l))) (define tail cdr) (define take (lambda (n l) (cond ((<= n 0) nil) ((null? l) nil) (else (cons (car l) (take (- n 1) (cdr l))))))) (define take-while (lambda (p l) (if (null? l) nil (if (p (car l)) (cons (car l) (take-while p (cdr l))) nil)))) (define transpose (lambda (l) (let ((protect (lambda (f) (lambda (x) (if (null? x) nil (f x)))))) (cond ((null? l) nil) ((null? (car l)) (transpose (cdr l))) (else (let* ((e (car l)) (x (car e)) (xs (cdr e)) (xss (cdr l))) (cons (cons x (filter (compose not null?) (map (protect car) xss))) (transpose (cons xs (map (protect cdr) xss)))))))))) (define unfoldr (lambda (f x) (let ((r (f x))) (if r (cons (car r) (unfoldr f (cdr r))) nil)))) (define union (lambda (a b) (union-by equal? a b))) (define union-by (lambda (f xs ys) (let ((g (lambda (x y) (delete-by f y x)))) (append xs (foldl g (nub-by f ys) xs))))) (define zip (lambda (a b) (zip-with cons a b))) (define zip-with (lambda (f a b) (cond ((null? a) nil) ((null? b) nil) (else (cons (f (car a) (car b)) (zip-with f (cdr a) (cdr b))))))) (define zip-with3 (lambda (f a b c) (cond ((null? a) nil) ((null? b) nil) ((null? c) nil) (else (cons (f (car a) (car b) (car c)) (zip-with3 f (cdr a) (cdr b) (cdr c))))))) (define compare (lambda (x y) (cond ((> x y) (quote gt)) ((< x y) (quote lt)) (else (quote eq))))) (define max (lambda (x y) (if (> x y) x y))) (define min (lambda (x y) (if (< x y) x y))) (define flatten* (lambda (t r) (cond ((null? t) r) ((pair? t) (flatten* (head t) (flatten* (tail t) r))) (else (cons t r))))) (define flatten (lambda (t) (flatten* t nil))) (define levels (lambda (t) (if (null? t) nil (let ((lr (partition* (compose not pair?) t))) (cons (car lr) (levels (concat (cdr lr)))))))) (define curry (lambda (f) (lambda (x y) (f (cons x y))))) (define uncurry (lambda (f) (lambda (c) (f (car c) (cdr c))))))